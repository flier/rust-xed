//! automatically generated by enum_gen.py, DON't EDIT IT

use std::{
    ffi::{CStr, CString, NulError},
    fmt,
    str::FromStr,
};

use derive_more::{From, Into};

use crate::ffi;

#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, From, Into)]
pub struct OperandElementType(ffi::xed_operand_element_type_enum_t);

impl OperandElementType {
    
    pub const INVALID : OperandElementType = OperandElementType(ffi::XED_OPERAND_ELEMENT_TYPE_INVALID);

    /// Unsigned integer
    pub const UINT : OperandElementType = OperandElementType(ffi::XED_OPERAND_ELEMENT_TYPE_UINT);

    /// Signed integer
    pub const INT : OperandElementType = OperandElementType(ffi::XED_OPERAND_ELEMENT_TYPE_INT);

    /// 32b FP single precision
    pub const SINGLE : OperandElementType = OperandElementType(ffi::XED_OPERAND_ELEMENT_TYPE_SINGLE);

    /// 64b FP double precision
    pub const DOUBLE : OperandElementType = OperandElementType(ffi::XED_OPERAND_ELEMENT_TYPE_DOUBLE);

    /// 80b FP x87
    pub const LONGDOUBLE : OperandElementType = OperandElementType(ffi::XED_OPERAND_ELEMENT_TYPE_LONGDOUBLE);

    /// 80b decimal BCD
    pub const LONGBCD : OperandElementType = OperandElementType(ffi::XED_OPERAND_ELEMENT_TYPE_LONGBCD);

    /// a structure of various fields
    pub const STRUCT : OperandElementType = OperandElementType(ffi::XED_OPERAND_ELEMENT_TYPE_STRUCT);

    /// depends on other fields in the instruction
    pub const VARIABLE : OperandElementType = OperandElementType(ffi::XED_OPERAND_ELEMENT_TYPE_VARIABLE);

    /// 16b floating point
    pub const FLOAT16 : OperandElementType = OperandElementType(ffi::XED_OPERAND_ELEMENT_TYPE_FLOAT16);

    /// bfloat16 floating point
    pub const BFLOAT16 : OperandElementType = OperandElementType(ffi::XED_OPERAND_ELEMENT_TYPE_BFLOAT16);
}

impl fmt::Display for OperandElementType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(unsafe {
            CStr::from_ptr(ffi::xed_operand_element_type_enum_t2str(self.0))
                .to_str()
                .unwrap()
        })
    }
}

impl FromStr for OperandElementType {
    type Err = NulError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let s = CString::new(s)?;

        Ok(OperandElementType(unsafe { ffi::str2xed_operand_element_type_enum_t(s.as_ptr()) }))
    }
}