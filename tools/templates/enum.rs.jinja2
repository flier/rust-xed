//! automatically generated by enum_gen.py, DON't EDIT IT

use std::{
    ffi::{CStr, CString, NulError},
    fmt,
    str::FromStr,
};

use derive_more::{From, Into};

use crate::ffi;

{% set name = enum.name | camel_case -%}

#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, From, Into)]
pub struct {{ name }}(ffi::{{ enum.metadata.typename }});

impl {{ name }} {
{%- for value in enum.values %}
    {% if value.comment -%}
    /// {{ value.comment }}
    {%- endif %}
    pub const {{ value.name | ident | upper }} : {{ name }} = {{ name }}(ffi::{{ enum.metadata.prefix }}{{ value.name }});
{% endfor -%}
}

impl fmt::Display for {{ name }} {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str(unsafe {
            CStr::from_ptr(ffi::{{ enum.metadata.typename }}2str(self.0))
                .to_str()
                .unwrap()
        })
    }
}

impl FromStr for {{ name }} {
    type Err = NulError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let s = CString::new(s)?;

        Ok({{ name }}(unsafe { ffi::str2{{ enum.metadata.typename }}(s.as_ptr()) }))
    }
}
